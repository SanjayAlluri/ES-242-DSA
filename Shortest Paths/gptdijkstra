#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

#define MAXN 1005

typedef struct {
    int v;  // neighbor vertex
    int w;  // edge weight
} Edge;

// Global graph variables
int n, m;
Edge* adj[MAXN];  // adjacency list: array of Edge structs
int deg[MAXN];    // degree of each vertex

// Global Dijkstra arrays
int dist[MAXN];
int visited[MAXN];
int parent[MAXN];

// Min-heap structure
typedef struct {
    int* nodes;
    int* heapDist;
    int size;
} MinHeap;

// Heap functions
MinHeap* createHeap(int capacity) {
    MinHeap* heap = (MinHeap*)malloc(sizeof(MinHeap));
    heap->nodes = (int*)malloc(capacity * sizeof(int));
    heap->heapDist = (int*)malloc(capacity * sizeof(int));
    heap->size = 0;
    return heap;
}

void swap(MinHeap* heap, int i, int j) {
    int temp_node = heap->nodes[i];
    int temp_dist = heap->heapDist[i];
    heap->nodes[i] = heap->nodes[j];
    heap->heapDist[i] = heap->heapDist[j];
    heap->nodes[j] = temp_node;
    heap->heapDist[j] = temp_dist;
}

void heapifyUp(MinHeap* heap, int idx) {
    while (idx > 0) {
        int parent = (idx - 1) / 2;
        if (heap->heapDist[idx] < heap->heapDist[parent]) {
            swap(heap, idx, parent);
            idx = parent;
        } else break;
    }
}

void heapifyDown(MinHeap* heap, int idx) {
    int smallest = idx;
    int left = 2*idx + 1;
    int right = 2*idx + 2;

    if (left < heap->size && heap->heapDist[left] < heap->heapDist[smallest])
        smallest = left;
    if (right < heap->size && heap->heapDist[right] < heap->heapDist[smallest])
        smallest = right;

    if (smallest != idx) {
        swap(heap, idx, smallest);
        heapifyDown(heap, smallest);
    }
}

void insertHeap(MinHeap* heap, int node, int distance) {
    heap->nodes[heap->size] = node;
    heap->heapDist[heap->size] = distance;
    heapifyUp(heap, heap->size);
    heap->size++;
}

int extractMin(MinHeap* heap) {
    int node = heap->nodes[0];
    heap->size--;
    heap->nodes[0] = heap->nodes[heap->size];
    heap->heapDist[0] = heap->heapDist[heap->size];
    heapifyDown(heap, 0);
    return node;
}

// Add weighted undirected edge
void addEdge(int u, int v, int w) {
    adj[u] = realloc(adj[u], (deg[u]+1)*sizeof(Edge));
    adj[u][deg[u]].v = v;
    adj[u][deg[u]].w = w;
    deg[u]++;

    adj[v] = realloc(adj[v], (deg[v]+1)*sizeof(Edge));
    adj[v][deg[v]].v = u;
    adj[v][deg[v]].w = w;
    deg[v]++;
}

// Dijkstra algorithm
void dijkstra(int src) {
    for (int i = 1; i <= n; i++) {
        dist[i] = INT_MAX;
        visited[i] = 0;
        parent[i] = -1;
    }
    dist[src] = 0;

    MinHeap* heap = createHeap(n);
    insertHeap(heap, src, 0);

    while (heap->size > 0) {
        int u = extractMin(heap);
        if (visited[u]) continue;
        visited[u] = 1;

        for (int i = 0; i < deg[u]; i++) {
            int v = adj[u][i].v;
            int w = adj[u][i].w;

            if (!visited[v] && dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
                parent[v] = u;
                insertHeap(heap, v, dist[v]);
            }
        }
    }

    // Print distances
    printf("Vertex\tDistance from Source\n");
    for (int i = 1; i <= n; i++)
        printf("%d\t%d\n", i, dist[i]);

    // Print shortest paths
    printf("\nShortest Paths:\n");
    for (int i = 1; i <= n; i++) {
        if (i == src) continue;
        printf("%d -> %d: ", src, i);
        int path[MAXN], k = 0, cur = i;
        while (cur != -1) {
            path[k++] = cur;
            cur = parent[cur];
        }
        for (int j = k-1; j >= 0; j--)
            printf("%d ", path[j]);
        printf("\n");
    }

    free(heap->nodes);
    free(heap->heapDist);
    free(heap);
}

int main() {
    scanf("%d %d", &n, &m);

    for (int i = 1; i <= n; i++) {
        adj[i] = NULL;
        deg[i] = 0;
    }

    for (int i = 0; i < m; i++) {
        int u, v, w;
        scanf("%d %d %d", &u, &v, &w);
        addEdge(u, v, w);
    }

    int src;
    scanf("%d", &src);
    dijkstra(src);

    // Free adjacency list memory
    for (int i = 1; i <= n; i++)
        free(adj[i]);

    return 0;
}
